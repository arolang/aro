<!DOCTYPE html>
<html lang="en">
<head>
    <title>Action Developer Guide - ARO Programming Language</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../animations.css">
    <!-- Matomo -->
    <script>
        var _paq = window._paq = window._paq || [];
        /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
        _paq.push(['trackPageView']);
        _paq.push(['enableLinkTracking']);
        (function() {
            var u="//matomo.benjamin.ausdertechnik.de/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '4']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
        })();
    </script>
    <!-- End Matomo Code -->

    <style>
        .doc-page {
            padding: 120px 24px 80px;
            max-width: 800px;
            margin: 0 auto;
        }

        .doc-page h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 24px;
            letter-spacing: -0.02em;
        }

        .doc-page h2 {
            font-size: 1.8rem;
            font-weight: 600;
            margin: 48px 0 16px;
            padding-top: 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .doc-page h3 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 32px 0 12px;
            color: var(--color-secondary);
        }

        .doc-page p {
            font-size: 1.1rem;
            color: var(--color-text-muted);
            line-height: 1.8;
            margin-bottom: 16px;
        }

        .doc-page code {
            font-family: var(--font-mono);
            background: var(--color-bg-alt);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .doc-page pre {
            background: var(--color-bg-alt);
            border-radius: var(--radius-md);
            padding: 20px;
            overflow-x: auto;
            margin: 24px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .doc-page pre code {
            background: none;
            padding: 0;
            font-size: 0.9rem;
            line-height: 1.7;
        }

        .doc-page ul, .doc-page ol {
            color: var(--color-text-muted);
            margin: 16px 0 16px 24px;
            line-height: 1.8;
        }

        .doc-page li {
            margin-bottom: 8px;
        }

        .doc-page table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
        }

        .doc-page th, .doc-page td {
            padding: 12px 16px;
            text-align: left;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .doc-page th {
            background: var(--color-bg-alt);
            font-weight: 600;
        }

        .doc-page blockquote {
            border-left: 4px solid var(--color-primary);
            padding-left: 20px;
            margin: 24px 0;
            color: var(--color-text);
            font-style: italic;
        }

        .doc-page strong {
            color: var(--color-text);
        }

        .doc-page em {
            color: var(--color-secondary);
        }

        .doc-page a {
            color: var(--color-primary);
            text-decoration: none;
        }

        .doc-page a:hover {
            text-decoration: underline;
        }

        .doc-page hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            margin: 48px 0;
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-content">
            <a href="/aro/" class="logo">
                <span class="logo-aro">ARO</span>
            </a>
            <div class="nav-links">
                <a href="../fdd.html">The FDD Story</a>
                <a href="../getting-started.html">Get Started</a>
                <a href="../tutorial.html">Tutorial</a>
                <a href="../docs.html" style="color: var(--color-text);">Docs</a>
                <a href="../disclaimer.html">Motivation</a>
                <a href="https://github.com/KrisSimon/aro" class="nav-github">GitHub</a>
            </div>
        </div>
    </nav>

    <main class="doc-page animate-on-scroll">
        <h1>Action Developer Guide</h1>
<p>This guide explains how to extend ARO with custom actions. Actions are the fundamental building blocks that implement ARO verbs like <code>&lt;Extract&gt;</code>, <code>&lt;Create&gt;</code>, <code>&lt;Return&gt;</code>, etc.</p>
<h2>Table of Contents</h2>
<ol>
<li><a href="#understanding-actions">Understanding Actions</a></li>
<li><a href="#the-actionimplementation-protocol">The ActionImplementation Protocol</a></li>
<li><a href="#action-roles">Action Roles</a></li>
<li><a href="#descriptors">Descriptors</a></li>
<li><a href="#execution-context">Execution Context</a></li>
<li><a href="#step-by-step-creating-a-custom-action">Step-by-Step: Creating a Custom Action</a></li>
<li><a href="#best-practices">Best Practices</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#testing-actions">Testing Actions</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ol>
<hr>
<h2>Understanding Actions</h2>
<p>In ARO, every statement follows the Action-Result-Object pattern:</p>
<pre><code class="language-aro">&lt;Verb&gt; the &lt;result&gt; from/to/with/for the &lt;object&gt;.
</code></pre>
<p>For example:</p>
<pre><code class="language-aro">&lt;Extract&gt; the &lt;user-id&gt; from the &lt;request: parameters&gt;.
&lt;Create&gt; the &lt;user&gt; with &lt;user-data&gt;.
&lt;Return&gt; an &lt;OK: status&gt; with &lt;response&gt;.
</code></pre>
<p>Each verb maps to an action implementation that:</p>
<ol>
<li>Receives structured information about the statement</li>
<li>Executes business logic</li>
<li>Returns a result to be bound to a variable</li>
</ol>
<hr>
<h2>The ActionImplementation Protocol</h2>
<pre><code class="language-swift">public protocol ActionImplementation: Sendable {
    /// The semantic role of this action
    static var role: ActionRole { get }

    /// The verbs that trigger this action
    static var verbs: Set&lt;String&gt; { get }

    /// Valid prepositions for object clauses
    static var validPrepositions: Set&lt;Preposition&gt; { get }

    /// Required initializer
    init()

    /// Execute the action
    func execute(
        result: ResultDescriptor,
        object: ObjectDescriptor,
        context: ExecutionContext
    ) async throws -&gt; any Sendable
}
</code></pre>
<h3>Key Points</h3>
<ul>
<li><strong>Sendable</strong>: Actions must be thread-safe</li>
<li><strong>Static properties</strong>: Define metadata at compile time</li>
<li><strong>Async/throws</strong>: Actions can be async and may throw errors</li>
<li><strong>Returns <code>any Sendable</code></strong>: Results must be sendable across concurrency domains</li>
</ul>
<hr>
<h2>Action Roles</h2>
<p>Actions are categorized by semantic role:</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Description</th>
<th>Example Verbs</th>
</tr>
</thead>
<tbody><tr>
<td><code>request</code></td>
<td>Request data from external sources</td>
<td>Extract, Retrieve, Fetch, Query</td>
</tr>
<tr>
<td><code>own</code></td>
<td>Create or modify owned data</td>
<td>Create, Compute, Transform, Validate</td>
</tr>
<tr>
<td><code>response</code></td>
<td>Send results or responses</td>
<td>Return, Respond, Reply</td>
</tr>
<tr>
<td><code>export</code></td>
<td>Export or publish data</td>
<td>Store, Publish, Log, Send</td>
</tr>
</tbody></table>
<pre><code class="language-swift">public enum ActionRole: String, Sendable {
    case request
    case own
    case response
    case export
}
</code></pre>
<p>Choose the role that best describes your action&#39;s primary purpose.</p>
<hr>
<h2>Descriptors</h2>
<h3>ResultDescriptor</h3>
<p>Information about the result variable:</p>
<pre><code class="language-swift">public struct ResultDescriptor: Sendable {
    public let identifier: String   // Variable name to bind (e.g., &quot;user-id&quot;)
    public let typeHint: String?    // Optional type (e.g., &quot;JSON&quot;)
    public let article: String      // &quot;a&quot;, &quot;an&quot;, or &quot;the&quot;
}
</code></pre>
<h3>ObjectDescriptor</h3>
<p>Information about the object clause:</p>
<pre><code class="language-swift">public struct ObjectDescriptor: Sendable {
    public let preposition: Preposition   // from, to, into, with, for
    public let sourceType: SourceType     // variable, literal, repository, etc.
    public let identifier: String         // Source identifier
    public let qualifier: String?         // Qualifier after &quot;:&quot; (e.g., &quot;body&quot; in &quot;request: body&quot;)
    public let condition: Condition?      // Optional where clause
}
</code></pre>
<h3>Source Types</h3>
<pre><code class="language-swift">public enum SourceType: String, Sendable {
    case variable       // Reference to a bound variable
    case literal        // Literal string value
    case repository     // Repository reference
    case service        // Service reference
    case event          // Event data reference
    case request        // HTTP request data
    case file           // File reference
}
</code></pre>
<h3>Prepositions</h3>
<pre><code class="language-swift">public enum Preposition: String, Sendable {
    case from     // Source of data
    case to       // Destination for data
    case into     // Storage target
    case with     // Additional data/parameters
    case forPrep  // Purpose or target
    case via      // Method or channel
    case at       // Location reference
    case on       // Target for operations
}
</code></pre>
<hr>
<h2>Execution Context</h2>
<p>The <code>ExecutionContext</code> provides access to runtime services:</p>
<pre><code class="language-swift">public protocol ExecutionContext: AnyObject, Sendable {
    // Variable Management
    func resolve&lt;T: Sendable&gt;(_ name: String) -&gt; T?
    func require&lt;T: Sendable&gt;(_ name: String) throws -&gt; T
    func bind(_ name: String, value: any Sendable)
    func exists(_ name: String) -&gt; Bool

    // Service Access
    func service&lt;S&gt;(_ type: S.Type) -&gt; S?

    // Repository Access
    func repository&lt;T&gt;(named: String) -&gt; (any Repository&lt;T&gt;)?

    // Response Management
    func setResponse(_ response: Response)
    func getResponse() -&gt; Response?

    // Event Emission
    func emit(_ event: any RuntimeEvent)

    // Metadata
    var featureSetName: String { get }
    var executionId: String { get }
}
</code></pre>
<h3>Variable Operations</h3>
<pre><code class="language-swift">// Get optional value
let name: String? = context.resolve(&quot;user-name&quot;)

// Get required value (throws if not found)
let userId: String = try context.require(&quot;user-id&quot;)

// Bind a new variable
context.bind(&quot;result&quot;, value: computedValue)

// Check existence
if context.exists(&quot;optional-param&quot;) {
    // ...
}
</code></pre>
<h3>Service Access</h3>
<pre><code class="language-swift">// Get a registered service
guard let httpClient = context.service(HTTPClientService.self) else {
    throw ActionError.serviceNotFound(&quot;HTTPClientService&quot;)
}
</code></pre>
<h3>Event Emission</h3>
<pre><code class="language-swift">// Emit domain events
context.emit(UserCreatedEvent(userId: newUser.id))
</code></pre>
<hr>
<h2>Step-by-Step: Creating a Custom Action</h2>
<h3>Step 1: Define Your Action</h3>
<pre><code class="language-swift">import ARORuntime

public struct EmailAction: ActionImplementation {
    // 1. Define the semantic role
    public static let role: ActionRole = .export

    // 2. Define verbs that trigger this action
    public static let verbs: Set&lt;String&gt; = [&quot;Email&quot;, &quot;Mail&quot;]

    // 3. Define valid prepositions
    public static let validPrepositions: Set&lt;Preposition&gt; = [.to, .with]

    // 4. Required initializer
    public init() {}

    // 5. Implement execute
    public func execute(
        result: ResultDescriptor,
        object: ObjectDescriptor,
        context: ExecutionContext
    ) async throws -&gt; any Sendable {
        // Implementation here
    }
}
</code></pre>
<h3>Step 2: Implement the Execute Method</h3>
<pre><code class="language-swift">public func execute(
    result: ResultDescriptor,
    object: ObjectDescriptor,
    context: ExecutionContext
) async throws -&gt; any Sendable {
    // Get required service
    guard let emailService = context.service(EmailService.self) else {
        throw ActionError.serviceNotFound(&quot;EmailService&quot;)
    }

    // Get the email content (from result identifier)
    let content: EmailContent = try context.require(result.identifier)

    // Get the recipient from the object
    let recipient: String
    switch object.sourceType {
    case .variable:
        recipient = try context.require(object.identifier)
    case .literal:
        recipient = object.identifier
    default:
        throw ActionError.invalidObjectSource(object.sourceType)
    }

    // Perform the action
    let sendResult = try await emailService.send(
        content: content,
        to: recipient
    )

    // Emit event for observability
    context.emit(EmailSentEvent(
        recipient: recipient,
        messageId: sendResult.messageId
    ))

    // Return the result
    return sendResult
}
</code></pre>
<h3>Step 3: Register Your Action</h3>
<pre><code class="language-swift">// In your application setup
ActionRegistry.shared.register(EmailAction.self)
</code></pre>
<h3>Step 4: Use in ARO</h3>
<pre><code class="language-aro">(Send Welcome Email: User Onboarding) {
    &lt;Create&gt; the &lt;email-content&gt; with {
        subject: &quot;Welcome to our platform!&quot;,
        body: &quot;Thanks for signing up...&quot;
    }.
    &lt;Extract&gt; the &lt;user-email&gt; from the &lt;user: email&gt;.
    &lt;Email&gt; the &lt;email-content&gt; to the &lt;user-email&gt;.
    &lt;Return&gt; an &lt;OK: status&gt; for the &lt;email&gt;.
}
</code></pre>
<hr>
<h2>Best Practices</h2>
<h3>1. Single Responsibility</h3>
<p>Each action should do one thing well:</p>
<pre><code class="language-swift">// Good: Focused action
public struct HashPasswordAction: ActionImplementation { ... }

// Bad: Action doing too much
public struct UserManagementAction: ActionImplementation { ... }
</code></pre>
<h3>2. Fail Fast with Descriptive Errors</h3>
<p>Validate inputs early:</p>
<pre><code class="language-swift">public func execute(...) async throws -&gt; any Sendable {
    // Validate required services
    guard let service = context.service(MyService.self) else {
        throw ActionError.serviceNotFound(&quot;MyService&quot;)
    }

    // Validate required variables
    let input: InputType = try context.require(result.identifier)

    // Validate preposition
    guard Self.validPrepositions.contains(object.preposition) else {
        throw ActionError.executionFailed(
            &quot;Invalid preposition &#39;\(object.preposition)&#39; for \(Self.verbs.first ?? &quot;action&quot;)&quot;
        )
    }

    // ... proceed with execution
}
</code></pre>
<h3>3. Use Strong Types</h3>
<p>Leverage Swift&#39;s type system:</p>
<pre><code class="language-swift">// Define domain types
public struct EmailContent: Sendable {
    let subject: String
    let body: String
    let attachments: [Attachment]
}

// Use in action
let content: EmailContent = try context.require(result.identifier)
</code></pre>
<h3>4. Emit Events for Observability</h3>
<pre><code class="language-swift">// Emit events for significant operations
context.emit(PaymentProcessedEvent(
    amount: amount,
    currency: currency,
    transactionId: result.id
))
</code></pre>
<h3>5. Handle Cleanup</h3>
<p>For actions that allocate resources:</p>
<pre><code class="language-swift">public func execute(...) async throws -&gt; any Sendable {
    let connection = try await openConnection()
    defer { connection.close() }

    return try await connection.execute(query)
}
</code></pre>
<h3>6. Document Your Action</h3>
<pre><code class="language-swift">/// Sends an email using the configured email service.
///
/// Usage in ARO:
/// ```aro
/// &lt;Email&gt; the &lt;content&gt; to the &lt;recipient&gt;.
/// ```
///
/// Requirements:
/// - EmailService must be registered
/// - Result must be EmailContent type
/// - Object must be a string (email address)
public struct EmailAction: ActionImplementation { ... }
</code></pre>
<hr>
<h2>Examples</h2>
<h3>Example 1: Data Transformation Action</h3>
<pre><code class="language-swift">public struct ParseJSONAction: ActionImplementation {
    public static let role: ActionRole = .own
    public static let verbs: Set&lt;String&gt; = [&quot;Parse&quot;, &quot;Decode&quot;]
    public static let validPrepositions: Set&lt;Preposition&gt; = [.from]

    public init() {}

    public func execute(
        result: ResultDescriptor,
        object: ObjectDescriptor,
        context: ExecutionContext
    ) async throws -&gt; any Sendable {
        // Get source string
        let jsonString: String = try context.require(object.identifier)

        // Parse JSON
        guard let data = jsonString.data(using: .utf8) else {
            throw ActionError.executionFailed(&quot;Invalid UTF-8 string&quot;)
        }

        let parsed = try JSONSerialization.jsonObject(with: data)

        // Bind result
        context.bind(result.identifier, value: parsed)

        return parsed
    }
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-aro">&lt;Parse&gt; the &lt;config&gt; from the &lt;json-string&gt;.
</code></pre>
<h3>Example 2: External API Action</h3>
<pre><code class="language-swift">public struct WeatherAction: ActionImplementation {
    public static let role: ActionRole = .request
    public static let verbs: Set&lt;String&gt; = [&quot;Weather&quot;, &quot;Forecast&quot;]
    public static let validPrepositions: Set&lt;Preposition&gt; = [.forPrep]

    public init() {}

    public func execute(
        result: ResultDescriptor,
        object: ObjectDescriptor,
        context: ExecutionContext
    ) async throws -&gt; any Sendable {
        guard let httpClient = context.service(HTTPClientService.self) else {
            throw ActionError.serviceNotFound(&quot;HTTPClientService&quot;)
        }

        // Get city from object
        let city: String
        switch object.sourceType {
        case .variable:
            city = try context.require(object.identifier)
        case .literal:
            city = object.identifier
        default:
            throw ActionError.invalidObjectSource(object.sourceType)
        }

        // Make API call
        let url = &quot;https://api.weather.com/v1/forecast?city=\(city)&quot;
        let response = try await httpClient.get(url: url)

        // Bind and return
        context.bind(result.identifier, value: response)
        return response
    }
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-aro">&lt;Weather&gt; the &lt;forecast&gt; for the &lt;city&gt;.
</code></pre>
<h3>Example 3: Repository Action</h3>
<pre><code class="language-swift">public struct FindAction: ActionImplementation {
    public static let role: ActionRole = .request
    public static let verbs: Set&lt;String&gt; = [&quot;Find&quot;, &quot;Lookup&quot;]
    public static let validPrepositions: Set&lt;Preposition&gt; = [.from]

    public init() {}

    public func execute(
        result: ResultDescriptor,
        object: ObjectDescriptor,
        context: ExecutionContext
    ) async throws -&gt; any Sendable {
        // Get repository
        guard let repo: any Repository&lt;Any&gt; = context.repository(
            named: object.identifier
        ) else {
            throw ActionError.repositoryNotFound(object.identifier)
        }

        // Apply condition if present
        let items: [Any]
        if let condition = object.condition {
            items = try await repo.find(where: condition)
        } else {
            items = try await repo.findAll()
        }

        context.bind(result.identifier, value: items)
        return items
    }
}
</code></pre>
<p>Usage:</p>
<pre><code class="language-aro">&lt;Find&gt; the &lt;users&gt; from the &lt;user-repository&gt; where status = &quot;active&quot;.
</code></pre>
<hr>
<h2>Testing Actions</h2>
<h3>Unit Testing</h3>
<pre><code class="language-swift">import XCTest
@testable import ARORuntime

final class EmailActionTests: XCTestCase {
    var mockContext: MockExecutionContext!
    var mockEmailService: MockEmailService!

    override func setUp() {
        mockEmailService = MockEmailService()
        mockContext = MockExecutionContext()
        mockContext.registerService(mockEmailService)
    }

    func testSendsEmail() async throws {
        // Arrange
        let content = EmailContent(subject: &quot;Test&quot;, body: &quot;Hello&quot;)
        mockContext.bind(&quot;email-content&quot;, value: content)

        let result = ResultDescriptor(
            identifier: &quot;email-content&quot;,
            typeHint: nil,
            article: &quot;the&quot;
        )
        let object = ObjectDescriptor(
            preposition: .to,
            sourceType: .literal,
            identifier: &quot;test@example.com&quot;,
            qualifier: nil,
            condition: nil
        )

        // Act
        let action = EmailAction()
        _ = try await action.execute(
            result: result,
            object: object,
            context: mockContext
        )

        // Assert
        XCTAssertEqual(mockEmailService.sentEmails.count, 1)
        XCTAssertEqual(mockEmailService.sentEmails[0].recipient, &quot;test@example.com&quot;)
    }

    func testThrowsWhenServiceMissing() async {
        // Arrange
        mockContext = MockExecutionContext() // No service registered

        let result = ResultDescriptor(identifier: &quot;content&quot;, typeHint: nil, article: &quot;the&quot;)
        let object = ObjectDescriptor(
            preposition: .to,
            sourceType: .literal,
            identifier: &quot;test@example.com&quot;,
            qualifier: nil,
            condition: nil
        )

        // Act &amp; Assert
        let action = EmailAction()
        await XCTAssertThrowsError(
            try await action.execute(result: result, object: object, context: mockContext)
        ) { error in
            XCTAssertEqual(error as? ActionError, .serviceNotFound(&quot;EmailService&quot;))
        }
    }
}
</code></pre>
<h3>Integration Testing</h3>
<pre><code class="language-swift">func testEmailActionIntegration() async throws {
    // Setup real application
    let app = Application(programs: [])
    app.register(service: RealEmailService(config: testConfig))
    ActionRegistry.shared.register(EmailAction.self)

    // Execute feature set that uses email action
    let program = try compile(&quot;&quot;&quot;
        (Send Test Email: Test) {
            &lt;Create&gt; the &lt;content&gt; with { subject: &quot;Test&quot;, body: &quot;Hello&quot; }.
            &lt;Email&gt; the &lt;content&gt; to &quot;test@example.com&quot;.
            &lt;Return&gt; an &lt;OK: status&gt; for the &lt;email&gt;.
        }
    &quot;&quot;&quot;)

    let result = try await app.execute(featureSet: &quot;Send Test Email&quot;, from: program)
    XCTAssertEqual(result.status, .ok)
}
</code></pre>
<hr>
<h2>Troubleshooting</h2>
<h3>Common Issues</h3>
<p><strong>Action not found</strong></p>
<pre><code>Error: No action registered for verb &#39;MyVerb&#39;
</code></pre>
<p>Solution: Ensure you&#39;ve called <code>ActionRegistry.shared.register(MyAction.self)</code></p>
<p><strong>Service not found</strong></p>
<pre><code>Error: Service &#39;MyService&#39; not found in context
</code></pre>
<p>Solution: Register the service with the application before running</p>
<p><strong>Variable not found</strong></p>
<pre><code>Error: Variable &#39;my-var&#39; not found in context
</code></pre>
<p>Solution: Ensure the variable is bound before accessing it</p>
<p><strong>Type mismatch</strong></p>
<pre><code>Error: Expected &#39;String&#39; but found &#39;Int&#39;
</code></pre>
<p>Solution: Check that bound values match expected types</p>
<h3>Debugging Tips</h3>
<ol>
<li><strong>Enable logging</strong>: Add logging to your action&#39;s execute method</li>
<li><strong>Check registration order</strong>: Services must be registered before actions that use them</li>
<li><strong>Inspect context state</strong>: Print bound variables during development</li>
<li><strong>Use breakpoints</strong>: Set breakpoints in execute() to inspect runtime state</li>
</ol>
<hr>
<h2>Summary</h2>
<p>Creating custom actions involves:</p>
<ol>
<li>Implementing <code>ActionImplementation</code> protocol</li>
<li>Defining role, verbs, and valid prepositions</li>
<li>Implementing async <code>execute</code> method</li>
<li>Registering with <code>ActionRegistry</code></li>
<li>Using in ARO code with the defined verbs</li>
</ol>
<p>Follow best practices for maintainable, testable actions that integrate well with the ARO runtime.</p>

    </main>

    <!-- Progress Bar -->
    <div class="progress-bar" id="progressBar"></div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="logo-aro">ARO</span>
                    <p>The ARO Programming Language</p>
                    <p class="footer-tagline">Speak Business. Write Code.</p>
                </div>
                <div class="footer-links">
                    <div class="footer-col">
                        <h4>Learn</h4>
                        <a href="../getting-started.html">Getting Started</a>
                        <a href="../tutorial.html">Tutorial</a>
                        <a href="../docs.html">Documentation</a>
                        <a href="../fdd.html">FDD History</a>
                    </div>
                    <div class="footer-col">
                        <h4>Community</h4>
                        <a href="https://github.com/KrisSimon/aro">GitHub</a>
                        <a href="https://github.com/KrisSimon/aro/issues">Issues</a>
                        <a href="../disclaimer.html">Motivation & Disclaimer</a>
                    </div>
                </div>
            </div>
            <div class="footer-bottom">
                <p>Sometime this page should build with ARO. Obviously.</p>
            </div>
        </div>
    </footer>

    <!-- Animation Scripts -->
    <script src="../animations.js"></script>

</body>
</html>
