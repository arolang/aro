(* ============================================================
   SystemMonitor - Terminal UI Example
   Demonstrates: Event-based Watch pattern with periodic updates
   ============================================================ *)

(Application-Start: System Monitor) {
    Log "System Monitor starting..." to the <console>.

    (* Emit initial MetricsUpdated event to trigger first render *)
    Create the <initial-metrics> with { cpu: 23, memory: 45, disk: 67 }.
    Emit a <MetricsUpdated: event> with <initial-metrics>.

    (* Keep application alive to handle events *)
    Keepalive the <application> for the <events>.

    Return an <OK: status> for the <startup>.
}

(* Watch handler - triggered by MetricsUpdated events *)
(Dashboard Watch: MetricsUpdated Handler) {
    (* Clear screen for fresh render - commented out for demo *)
    (* Clear the <screen> for the <terminal>. *)

    (* Display metrics *)
    Log "=== System Monitor ===" to the <console>.
    Log "Metrics updated via event!" to the <console>.
    Log "Event-based Watch pattern is working!" to the <console>.

    (* Note: In a real application, you would:
       1. Extract metrics from event payload
       2. Collect actual system metrics
       3. Schedule next update by emitting event after delay
       For now, this just demonstrates the reactive pattern *)

    Return an <OK: status> for the <render>.
}

(* Optional: Feature set to update metrics periodically *)
(Collect Metrics: MetricsCollected Handler) {
    (* In a real app, you would:
       - Read actual CPU, memory, disk usage
       - Emit MetricsUpdated event with real data *)

    Create the <new-metrics> with { cpu: 45, memory: 67, disk: 89 }.
    Emit a <MetricsUpdated: event> with <new-metrics>.

    Return an <OK: status> for the <collection>.
}
